---
title: NIO
date: 2019-02-17 22:30:20
tags:
- 数据传输
categories:
- 数据传输
---

#### NIO是什么？

​    在 JDK 1. 4 中 新 加入 了 NIO( New Input/ Output) 类, 引入了一种基于通道和缓冲区的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆的 DirectByteBuffer 对象作为这块内存的引用进行操作，避免了在 Java 堆和 Native 堆中来回复制数据。

​    NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务。同步的核心就是 Selector，**Selector 代替了线程本身轮询 IO 事件**，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是通道和缓冲区**，当 IO 事件就绪时，可以通过写道缓冲区，保证 IO 的成功，而无需线程阻塞式地等待**。



   这边主要了解一下NIO同步核心Selector

  通道和缓冲区的机制，使得线程无需阻塞地等待IO事件的就绪，但是总是要有人来监管这些IO事件。这个工作就交给了selector来完成，这就是所谓的同步。

​    **Selector允许单线程处理多个 Channel**。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。

​    要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪，这就是所说的轮询。一旦这个方法返回，线程就可以处理这些事件。

   在网络开发选择NIO的原因就是，NIO解决了jkd源生IO编程效率低下，资源有限的问题。

   源生IO会给每一个接受到的连接创建一个新线程，这个线程来死循环读取数据。死循环的目的就是不断监测这条连接上是否有数据可以读。有很多连接根本没用数据，很多死循环就浪费了,当接收的连接一多，就会出现问题.

   NIO只有一个死循环，用于处理数据。还有Selector，所有接收到的连接全部会注册到selector，通过检查selector，就可以批量的检查连接是否有数据，然后再进行读取。

   